<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MultiBisect.jl</title><meta name="title" content="Home · MultiBisect.jl"/><meta property="og:title" content="Home · MultiBisect.jl"/><meta property="twitter:title" content="Home · MultiBisect.jl"/><meta name="description" content="Documentation for MultiBisect.jl."/><meta property="og:description" content="Documentation for MultiBisect.jl."/><meta property="twitter:description" content="Documentation for MultiBisect.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>MultiBisect.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#The-Problem"><span>The Problem</span></a></li><li><a class="tocitem" href="#Bisection"><span>Bisection</span></a></li><li><a class="tocitem" href="#Interpolation"><span>Interpolation</span></a></li><li><a class="tocitem" href="#More-dimensions!"><span>More dimensions!</span></a></li></ul></li><li><a class="tocitem" href="api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jbshannon/MultiBisect.jl/blob/main/docs/src/index.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="MultiBisect.jl"><a class="docs-heading-anchor" href="#MultiBisect.jl">MultiBisect.jl</a><a id="MultiBisect.jl-1"></a><a class="docs-heading-anchor-permalink" href="#MultiBisect.jl" title="Permalink"></a></h1><p>This Julia package provides a lightweight, idiomatic implementation of the <a href="https://en.wikipedia.org/wiki/Bisection_method">bisection method</a> of root-finding in an arbitrary number of dimensions.</p><p>This package exports the <code>BisectionGrid</code> type, which tracks an <code>N</code>-dimensional bisection with only three <code>Array{Bool, N}</code>s and one <code>NTuple{N, R &lt;: AbstractRange}</code>. Using ordinary boolean arrays not only uses minimal memory, but also leverages the magic of base Julia&#39;s <code>CartesianIndices</code> to handle any number of dimensions without code modification.</p><blockquote><p>[!IMPORTANT] This package, while functional, is still experimental and subject to change. For a more mature package with similar functionality, see <a href="https://github.com/bachrathyd/MDBM.jl">MDBM.jl</a></p></blockquote><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>This package is not yet registered, so installation is only available by url from the <code>pkg&gt;</code> prompt:</p><pre><code class="language-julia-repl hljs">pkg&gt; add https://github.com/jbshannon/MultiBisect.jl</code></pre><h2 id="The-Problem"><a class="docs-heading-anchor" href="#The-Problem">The Problem</a><a id="The-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#The-Problem" title="Permalink"></a></h2><p>The task of finding the root of a continuous function on an interval where its sign is known to change is a relatively well-known and simple problem, but extending the method to handle two or more dimensions adds complexity. For example, consider the unit circle on the domain <span>$[0,1]^2$</span>.</p><pre><code class="language-julia hljs">f(z) = 1 - sum(abs2, z)
circle = map(t -&gt; (cos(t), sin(t)), 0:0.01:π/2)

using CairoMakie
fig = Figure(resolution = (500, 500))
ax = Axis(fig[1, 1])
lines!(ax, circle; color=:black)
fig</code></pre><p><img src="images/README/circle1.svg" alt/></p><p>The naive, brute-force approach would be to evaluate the function on a grid of points, but many of these evaluations would be far away from the root (in two dimensions, a zero level curve) and not provide any information about the shape of the level curve.</p><pre><code class="language-julia hljs">xs = range(0, 1, length=65)
XS = Iterators.product(xs, xs) |&gt; collect
F = f.(XS)

scatter!(ax, XS[F .&gt; 0]; markersize=3)
scatter!(ax, XS[F .≤ 0]; markersize=3)
fig</code></pre><p><img src="images/README/circle2.svg" alt/></p><p>The level curve must lie between the positive points and the negative points. Two adjacent points that share the same sign do not tell us anything about the level curve, so we could improve our efficiency if we avoided evaluating the function in regions where the sign does not appear to change.</p><h2 id="Bisection"><a class="docs-heading-anchor" href="#Bisection">Bisection</a><a id="Bisection-1"></a><a class="docs-heading-anchor-permalink" href="#Bisection" title="Permalink"></a></h2><p>Using the bisection method, we can reduce the number of function evaluations by increasing the fineness of the grid only in places we know the function must change sign. This package provides the function <code>bisect(f, grid)</code>, which applies the algorithm iteratively to the <code>grid</code> using the function <code>f</code>:</p><pre><code class="language-julia hljs">using MultiBisect
BG = bisect(f, (0.0:1.0, 0.0:1.0); iterations=7)
posx, negx = splitsign(BG)

fig = Figure(resolution = (500, 500))
ax = Axis(fig[1, 1])
lines!(ax, circle; color=:black)
scatter!(ax, posx; markersize=3)
scatter!(ax, negx; markersize=3)
fig</code></pre><p><img src="images/README/circle3.svg" alt/></p><p>The resulting grid is the same size and identifies the exact same sign changes as before, but with far fewer function evaluations – nearly 90% fewer!</p><pre><code class="language-julia-repl hljs">julia&gt; BG
BisectionGrid{Float64, 2}
       Domain: (0.0:0.015625:1.0, 0.0:0.015625:1.0)
  Grid points: 4225
  Evaluations: 490


julia&gt; (xs, xs) == domain(BG)
true

julia&gt; efficiency(BG) # percentage of gridpoints not evaluated
0.8840236686390532</code></pre><p>This efficiency gain is possible because we known that if a square in the grid has vertices that are not all the same sign, the function must change sign somewhere within the square (this is of course only a necessary and not a sufficient condition). The method proceeds by dividing an initial grid &quot;in half&quot; (in the multidimensional sense) at each stage. Since we are working in two dimensions, we break each square into four smaller squares. Before evaluating the function, we check the sign of the function at teh vertices of the larger square. If the function does not change sign, there is no need to evaluate the function within the square. By discarding squares whose vertices all share the same sign at each iteration, we avoid uninformative function evaluations. Here is a step-by-step view of the algorithm:</p><p>https://github.com/jbshannon/MultiBisect.jl/assets/46204520/f4fa8893-f073-40f7-8907-84308b91cc65</p><h2 id="Interpolation"><a class="docs-heading-anchor" href="#Interpolation">Interpolation</a><a id="Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation" title="Permalink"></a></h2><p>Once we&#39;re satisfied we have enough information about where the function changes signs, we need to convert that information into actual points along the curve. This package examines the <em>edges</em> of the grid: two adjacent points with opposite signs. </p><pre><code class="language-julia-repl hljs">julia&gt; edges(BG)
128-element Vector{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}:
 ((0.984375, 0.0), (1.0, 0.0))
 ((0.984375, 0.015625), (1.0, 0.015625))
 ((0.984375, 0.03125), (1.0, 0.03125))
 ((0.984375, 0.046875), (1.0, 0.046875))
 ((0.984375, 0.0625), (1.0, 0.0625))
 ⋮
 ((0.125, 0.984375), (0.125, 1.0))
 ((0.140625, 0.984375), (0.140625, 1.0))
 ((0.15625, 0.984375), (0.15625, 1.0))
 ((0.171875, 0.984375), (0.1875, 0.984375))
 ((0.171875, 0.984375), (0.171875, 1.0))</code></pre><p>Since an edge is one-dimensional, we can convert the multidimensional root-finding problem to a series of one-dimensional problems. This packages provides the function <code>interpolate(rootfinder, BG)</code>, which takes a function <code>rootfinder</code> – taking an edge as input and returning a root as output – and applies it to each edge in the grid <code>BG</code>. This package currently provides three root-finders for convenience:</p><ul><li><code>edgeroot</code>: solve for the root on the edge with a call to <code>Roots.find_zero</code></li><li><code>linearroot</code>: create a linear interpolation of the function through the two edge points and compute its root</li><li><code>marchingsquares</code>: return the midpoint of the edge</li></ul><p>Here is a visual comparison of these different interpolation methods:</p><p><img src="images/README/interpolations.svg" alt/></p><h2 id="More-dimensions!"><a class="docs-heading-anchor" href="#More-dimensions!">More dimensions!</a><a id="More-dimensions!-1"></a><a class="docs-heading-anchor-permalink" href="#More-dimensions!" title="Permalink"></a></h2><p>Since Julia has the magical <code>CartesianIndices</code> iterator, translating this process out of two dimensions is as simple as changing the dimension of the initial evaluation grid. Here is an example finding roots of the 5d unit hypersphere over the 5d unit hypercube:</p><pre><code class="language-julia-repl hljs">julia&gt; grid = ntuple(i -&gt; (0.0:1.0), 5)
(0.0:1.0:1.0, 0.0:1.0:1.0, 0.0:1.0:1.0, 0.0:1.0:1.0, 0.0:1.0:1.0)

julia&gt; BG5 = bisect(f, grid)
BisectionGrid{Float64, 5}
       Domain: (0.0:0.0625:1.0, 0.0:0.0625:1.0, 0.0:0.0625:1.0, 0.0:0.0625:1.0, 0.0:0.0625:1.0)
  Grid points: 1419857
  Evaluations: 396246

julia&gt; interpolate(linearroot(f), BG5)
124020-element Vector{NTuple{5, Float64}}:
 (1.0, 0.0, 0.0, 0.0, 0.0)
 (0.9979838709677419, 0.0625, 0.0, 0.0, 0.0)
 (0.9919354838709677, 0.125, 0.0, 0.0, 0.0)
 (0.9818548387096774, 0.1875, 0.0, 0.0, 0.0)
 (0.967741935483871, 0.25, 0.0, 0.0, 0.0)
 ⋮
 (0.0625, 0.0625, 0.125, 0.3125, 0.9375)
 (0.0, 0.08333333333333333, 0.125, 0.3125, 0.9375)
 (0.0, 0.0625, 0.1375, 0.3125, 0.9375)
 (0.0, 0.0625, 0.125, 0.3181818181818182, 0.9375)
 (0.0, 0.0625, 0.125, 0.3125, 0.9395161290322581)</code></pre></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="api/">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.1 on <span class="colophon-date" title="Thursday 28 March 2024 19:24">Thursday 28 March 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
