<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · MultiBisect.jl</title><meta name="title" content="API Reference · MultiBisect.jl"/><meta property="og:title" content="API Reference · MultiBisect.jl"/><meta property="twitter:title" content="API Reference · MultiBisect.jl"/><meta name="description" content="Documentation for MultiBisect.jl."/><meta property="og:description" content="Documentation for MultiBisect.jl."/><meta property="twitter:description" content="Documentation for MultiBisect.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MultiBisect.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jbshannon/MultiBisect.jl/blob/main/docs/src/api.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><ul><li><a href="#MultiBisect.bisect-Tuple{Any, Any}"><code>MultiBisect.bisect</code></a></li><li><a href="#MultiBisect.corners-Tuple{CartesianIndices}"><code>MultiBisect.corners</code></a></li><li><a href="#MultiBisect.domainindex-Union{Tuple{N}, Tuple{Any, CartesianIndex{N}}} where N"><code>MultiBisect.domainindex</code></a></li><li><a href="#MultiBisect.edgebounds-Tuple{Any}"><code>MultiBisect.edgebounds</code></a></li><li><a href="#MultiBisect.edgedim-Tuple{Any}"><code>MultiBisect.edgedim</code></a></li><li><a href="#MultiBisect.edgeroot-Tuple{Any, Any, Any}"><code>MultiBisect.edgeroot</code></a></li><li><a href="#MultiBisect.edges-Union{Tuple{BisectionGrid{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>MultiBisect.edges</code></a></li><li><a href="#MultiBisect.edgetuple-Tuple{Any}"><code>MultiBisect.edgetuple</code></a></li><li><a href="#MultiBisect.expandzeros-Tuple{Any}"><code>MultiBisect.expandzeros</code></a></li><li><a href="#MultiBisect.findhypercubes-Tuple{Any}"><code>MultiBisect.findhypercubes</code></a></li><li><a href="#MultiBisect.forwardinds-Tuple{Any}"><code>MultiBisect.forwardinds</code></a></li><li><a href="#MultiBisect.interpolate-Tuple{Any, BisectionGrid}"><code>MultiBisect.interpolate</code></a></li><li><a href="#MultiBisect.interpolate-Tuple{BisectionGrid}"><code>MultiBisect.interpolate</code></a></li><li><a href="#MultiBisect.linearroot-Tuple{Any, Any}"><code>MultiBisect.linearroot</code></a></li><li><a href="#MultiBisect.marchingsquares-Tuple{Any}"><code>MultiBisect.marchingsquares</code></a></li><li><a href="#MultiBisect.splitsign-Tuple{BisectionGrid}"><code>MultiBisect.splitsign</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiBisect.bisect-Tuple{Any, Any}" href="#MultiBisect.bisect-Tuple{Any, Any}"><code>MultiBisect.bisect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bisect(f, grid; threaded=false, monotonic=false, iterations=5, verbose=false)</code></pre><p>Perform the multidimensional bisection algorithm of function <code>f</code> on an initial <code>grid</code> of evaluation points.</p><p><strong>Arguments</strong></p><p><strong>Positional Arguments</strong></p><ul><li><code>f</code>: function to be evaluated</li><li><code>grid</code>: a tuple of ranges describing the initial evaluation grid</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>threaded</code>: set to <code>true</code> for multithreaded evaluation</li><li><code>monotonic</code>: set to true if <code>f</code> is known to be monotonic in each dimension</li><li><code>iterations</code>: number of times to iterate the algorithm</li><li><code>verbose</code>: set to <code>true</code> to print the number of new function evaluations at each iteration</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; grid = (0.0:1.0, 0.0:1.0);

julia&gt; bisect(x -&gt; 1 - sum(abs2, x), grid)
BisectionGrid{Float64, 2}
       Domain: (0.0:0.0625:1.0, 0.0:0.0625:1.0)
  Grid points: 289
  Evaluations: 112
        Edges: 32


julia&gt; bisect(x -&gt; x[2] - x[1], grid)
BisectionGrid{Float64, 2}
       Domain: (0.0:0.0625:1.0, 0.0:0.0625:1.0)
  Grid points: 289
  Evaluations: 112
        Edges: 32


julia&gt; bisect(x -&gt; x[2] - x[1], grid; monotonic=true)
BisectionGrid{Float64, 2}
       Domain: (0.0:0.0625:1.0, 0.0:0.0625:1.0)
  Grid points: 289
  Evaluations: 67
        Edges: 32</code></pre><p><strong>Extended help</strong></p><p><strong>Algorithm</strong></p><p>The algorithm begins with an initial evaluation grid of <span>$N$</span>-dimensional hypercubes (lines, squares, cubes, etc.) and proceeds by splitting it in &quot;half&quot; at each stage, but only in regions where the function is known to change sign. After the function is evaluated, each hypercube is split in half (a line into two lines, a square into four squares, a cube into eight cubes, etc.) and the function sign at each vertex is checked. If not all vertices share the same sign, the function must change sign somewhere within the hypercube, so the vertices of the subcubes (e.g. the midpoint of a line) will be marked for evaluation in the next stage; if the vertices all share the same sign, the function is presumed to have the same sign everywhere throughout the hypercube, so the sign is inferred at all interior points and the function is not evaluated in the hypercube again.</p><p>By passing the keyword <code>monotonic=true</code>, the algorithm further assumes that the function cannot change sign in any one direction between two points with the same sign. This means that the sign of the function should be checked at the vertices of each edge of the hypercube; if the signs are the same, the function is assumed to have the same sign at the midpoint along the edge and will not be evaluated.</p><p><strong>Multithreading</strong></p><p>Set the keyword argument <code>threaded=true</code> to make evaluation of the function at each iteration multithreaded. For functions that are very cheap to evaluate, the overhead from setting up threads will actually make each iteration longer. However, this effect disappears quickly.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ffast(x) = 1 - sum(abs2, x);

julia&gt; grid = (0.0:1.0, 0.0:1.0);

julia&gt; @btime bisect(ffast, $grid; threaded=false);
  49.720 μs (40 allocations: 3.59 KiB)

julia&gt; @btime bisect(ffast, $grid; threaded=true);
  146.173 μs (163 allocations: 18.23 KiB)

julia&gt; fslow(x) = (sleep(0.1); ffast(x))
fslow (generic function with 1 method)

julia&gt; @btime bisect(fslow, $grid; threaded=false);
  11.397 s (605 allocations: 20.83 KiB)

julia&gt; @btime bisect(fslow, $grid; threaded=true);
  3.170 s (736 allocations: 35.45 KiB)</code></pre><p><strong>Monotonicity</strong></p><p>If the function <code>f</code> is known to be monotonic, then the number of evaluations can be reduced by inferring the behavior of <code>f</code> along edges where both vertices have the same sign.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bisect(x -&gt; 1 - sum(abs2, x), (0.0:1.0, 0.0:1.0); monotonic=false)
BisectionGrid{Float64, 2}
       Domain: (0.0:0.0625:1.0, 0.0:0.0625:1.0)
  Grid points: 289
  Evaluations: 112
        Edges: 32


julia&gt; bisect(x -&gt; 1 - sum(abs2, x), (0.0:1.0, 0.0:1.0); monotonic=true)
BisectionGrid{Float64, 2}
       Domain: (0.0:0.0625:1.0, 0.0:0.0625:1.0)
  Grid points: 289
  Evaluations: 80
        Edges: 32</code></pre><p><strong>Iterations</strong></p><p>For finer grids, repeat the algorithm for more iterations.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bisect(x -&gt; 1 - sum(abs2, x), (0.0:1.0, 0.0:1.0))
BisectionGrid{Float64, 2}
       Domain: (0.0:0.0625:1.0, 0.0:0.0625:1.0)
  Grid points: 289
  Evaluations: 112
        Edges: 32


julia&gt; bisect(x -&gt; 1 - sum(abs2, x), (0.0:1.0, 0.0:1.0); iterations=3)
BisectionGrid{Float64, 2}
       Domain: (0.0:0.25:1.0, 0.0:0.25:1.0)
  Grid points: 25
  Evaluations: 22
        Edges: 8


julia&gt; bisect(x -&gt; 1 - sum(abs2, x), (0.0:1.0, 0.0:1.0); iterations=7)
BisectionGrid{Float64, 2}
       Domain: (0.0:0.015625:1.0, 0.0:0.015625:1.0)
  Grid points: 4225
  Evaluations: 490
        Edges: 128</code></pre><p><strong>Logging</strong></p><p>For longer-running bisections, it may be useful to report the number of new evaluations as a kind of thread-safe progress meter.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bisect(x -&gt; 1 - sum(abs2, x), (0.0:1.0, 0.0:1.0); verbose=true)
[ Info: Iteration 1: 4 gridpoints (4 evaluations)
[ Info: Iteration 2: 9 gridpoints (5 evaluations)
[ Info: Iteration 3: 25 gridpoints (13 evaluations)
[ Info: Iteration 4: 81 gridpoints (29 evaluations)
[ Info: Iteration 5: 289 gridpoints (61 evaluations)
BisectionGrid{Float64, 2}
       Domain: (0.0:0.0625:1.0, 0.0:0.0625:1.0)
  Grid points: 289
  Evaluations: 112
        Edges: 32


julia&gt; bisect(x -&gt; 1 - sum(abs2, x), (0.0:1.0, 0.0:1.0); verbose=true, iterations=7)
[ Info: Iteration 1: 4 gridpoints (4 evaluations)
[ Info: Iteration 2: 9 gridpoints (5 evaluations)
[ Info: Iteration 3: 25 gridpoints (13 evaluations)
[ Info: Iteration 4: 81 gridpoints (29 evaluations)
[ Info: Iteration 5: 289 gridpoints (61 evaluations)
[ Info: Iteration 6: 1089 gridpoints (125 evaluations)
[ Info: Iteration 7: 4225 gridpoints (253 evaluations)
BisectionGrid{Float64, 2}
       Domain: (0.0:0.015625:1.0, 0.0:0.015625:1.0)
  Grid points: 4225
  Evaluations: 490
        Edges: 128</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbshannon/MultiBisect.jl/blob/f869351e8904f15a235fc8309d512480ac7b6dd6/src/bisection.jl#L399-L567">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiBisect.corners-Tuple{CartesianIndices}" href="#MultiBisect.corners-Tuple{CartesianIndices}"><code>MultiBisect.corners</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">corners(CI::CartesianIndices)</code></pre><p>Construct an iterator over the corners of the hypercube defined by <code>CI</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; CI = CartesianIndices((1:3, 1:4))
CartesianIndices((1:3, 1:4))

julia&gt; collect(CI)
3×4 Matrix{CartesianIndex{2}}:
 CartesianIndex(1, 1)  CartesianIndex(1, 2)  …  CartesianIndex(1, 4)
 CartesianIndex(2, 1)  CartesianIndex(2, 2)     CartesianIndex(2, 4)
 CartesianIndex(3, 1)  CartesianIndex(3, 2)     CartesianIndex(3, 4)

julia&gt; corners(CI)
CartesianIndices((1:2:3, 1:3:4))

julia&gt; collect(corners(CI))
2×2 Matrix{CartesianIndex{2}}:
 CartesianIndex(1, 1)  CartesianIndex(1, 4)
 CartesianIndex(3, 1)  CartesianIndex(3, 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbshannon/MultiBisect.jl/blob/f869351e8904f15a235fc8309d512480ac7b6dd6/src/bisection.jl#L187-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiBisect.domainindex-Union{Tuple{N}, Tuple{Any, CartesianIndex{N}}} where N" href="#MultiBisect.domainindex-Union{Tuple{N}, Tuple{Any, CartesianIndex{N}}} where N"><code>MultiBisect.domainindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">domainindex(X, I::CartesianIndex)</code></pre><p>Like <code>getindex</code>, except <code>X</code> is a tuple of ranges instead of an array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = (1.0:5.0, 0.5:2.5);

julia&gt; domainindex(X, CartesianIndex(1, 1))
(1.0, 0.5)

julia&gt; domainindex(X, CartesianIndex(2, 1))
(2.0, 0.5)

julia&gt; domainindex(X, CartesianIndex(1, 2))
(1.0, 1.5)

julia&gt; domainindex(X, last(CartesianIndices(eachindex.(X))))
(5.0, 2.5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbshannon/MultiBisect.jl/blob/f869351e8904f15a235fc8309d512480ac7b6dd6/src/interpolation.jl#L23-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiBisect.edgebounds-Tuple{Any}" href="#MultiBisect.edgebounds-Tuple{Any}"><code>MultiBisect.edgebounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edgebounds(edge)</code></pre><p>Return the bounds of the edge in its varying dimension.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; edgebounds(((0.5, 1.0), (1.0, 1.0)))
(0.5, 1.0)

julia&gt; edgebounds(((0.5, 1.0), (0.5, 1.5)))
(1.0, 1.5)

julia&gt; edgebounds(((1.0, 1.0, 1.0), (1.0, 1.0, 2.0)))
(1.0, 2.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbshannon/MultiBisect.jl/blob/f869351e8904f15a235fc8309d512480ac7b6dd6/src/interpolation.jl#L86-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiBisect.edgedim-Tuple{Any}" href="#MultiBisect.edgedim-Tuple{Any}"><code>MultiBisect.edgedim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edgedim(edge)</code></pre><p>Return the dimension of the edge (i.e. the only direction in which the vertices vary).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; edgedim(((0.5, 1.0), (1.0, 1.0)))
1

julia&gt; edgedim(((0.5, 1.0), (0.5, 1.5)))
2

julia&gt; edgedim(((1.0, 1.0, 1.0), (1.0, 1.0, 2.0)))
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbshannon/MultiBisect.jl/blob/f869351e8904f15a235fc8309d512480ac7b6dd6/src/interpolation.jl#L66-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiBisect.edgeroot-Tuple{Any, Any, Any}" href="#MultiBisect.edgeroot-Tuple{Any, Any, Any}"><code>MultiBisect.edgeroot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edgeroot(f, edge, M; kwargs...)</code></pre><p>Find the root along <code>edge</code> with a call to <code>Roots.find_zero</code>. Both <code>M</code> and <code>kwargs</code> are passed directly to <code>find_zero</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f(x) = 1 - sum(abs2, x); # unit circle

julia&gt; BG = bisect(f, (0.0:1.0, 0.0:1.0); iterations=3);

julia&gt; E = edges(BG)
8-element Vector{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}:
 ((0.75, 0.0), (1.0, 0.0))
 ((0.75, 0.25), (1.0, 0.25))
 ((0.75, 0.5), (1.0, 0.5))
 ((0.75, 0.5), (0.75, 0.75))
 ((0.0, 0.75), (0.0, 1.0))
 ((0.25, 0.75), (0.25, 1.0))
 ((0.5, 0.75), (0.75, 0.75))
 ((0.5, 0.75), (0.5, 1.0))

julia&gt; tracks = Roots.Tracks();

julia&gt; root = edgeroot(f, E[3], Roots.ITP(); tracks)
(0.8660254037844387, 0.5)

julia&gt; f(root)
0.0

julia&gt; tracks
Results of univariate zero finding:

* Converged to: 0.8660254037844387
* Algorithm: Roots.ITP{Float64, Int64}(0.2, 2, 1)
* iterations: 7
* function evaluations ≈ 9
* stopped as f(x_n) = 0

Trace:
(a₀, b₀) = ( 0.75, 1 )
(a₁, b₁) = ( 0.75, 0.86964285714285705 )
(a₂, b₂) = ( 0.86290337975046705, 0.86964285714285705 )
(a₃, b₃) = ( 0.86290337975046705, 0.8660279692952968 )
(a₄, b₄) = ( 0.86602344653979335, 0.8660279692952968 )
(a₅, b₅) = ( 0.86602344653979335, 0.86602540378563075 )
(a₆, b₆) = ( 0.86602540378367243, 0.86602540378563075 )
(a₇, b₇) = ( 0.86602540378443871, 0.86602540378563075 )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbshannon/MultiBisect.jl/blob/f869351e8904f15a235fc8309d512480ac7b6dd6/src/interpolation.jl#L129-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiBisect.edges-Union{Tuple{BisectionGrid{T, N}}, Tuple{N}, Tuple{T}} where {T, N}" href="#MultiBisect.edges-Union{Tuple{BisectionGrid{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>MultiBisect.edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edges(BG::BisectionGrid)</code></pre><p>Find all hypercube edges where the sign of the function changes. Returns a <code>Vector</code> of 2-tuples of points in the domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbshannon/MultiBisect.jl/blob/f869351e8904f15a235fc8309d512480ac7b6dd6/src/interpolation.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiBisect.edgetuple-Tuple{Any}" href="#MultiBisect.edgetuple-Tuple{Any}"><code>MultiBisect.edgetuple</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edgetuple(edge)</code></pre><p>Return a function converting a value along the edge dimension to a point.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tup = edgetuple(((0.5, 1.0), (1.0, 1.0)));

julia&gt; tup(0.75)
(0.75, 1.0)

julia&gt; tup(0.9)
(0.9, 1.0)

julia&gt; edgetuple(((0.5, 1.0), (0.5, 1.5)))(1.2)
(0.5, 1.2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbshannon/MultiBisect.jl/blob/f869351e8904f15a235fc8309d512480ac7b6dd6/src/interpolation.jl#L107-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiBisect.expandzeros-Tuple{Any}" href="#MultiBisect.expandzeros-Tuple{Any}"><code>MultiBisect.expandzeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expandzeros(A)</code></pre><p>Expand the array A, inserting a zero between each element.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(1:4, 2, 2)
2×2 reshape(::UnitRange{Int64}, 2, 2) with eltype Int64:
 1  3
 2  4

julia&gt; expandzeros(A)
3×3 Matrix{Int64}:
 1  0  3
 0  0  0
 2  0  4

julia&gt; B = reshape(1:6, 3, 2)
3×2 reshape(::UnitRange{Int64}, 3, 2) with eltype Int64:
 1  4
 2  5
 3  6

julia&gt; expandzeros(B)
5×3 Matrix{Int64}:
 1  0  4
 0  0  0
 2  0  5
 0  0  0
 3  0  6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbshannon/MultiBisect.jl/blob/f869351e8904f15a235fc8309d512480ac7b6dd6/src/bisection.jl#L109-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiBisect.findhypercubes-Tuple{Any}" href="#MultiBisect.findhypercubes-Tuple{Any}"><code>MultiBisect.findhypercubes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findhypercubes(A; dist=2)</code></pre><p>Find the starting vertex of all hypercubes in the array <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = ones(Bool, 5, 5)
5×5 Matrix{Bool}:
 1  1  1  1  1
 1  1  1  1  1
 1  1  1  1  1
 1  1  1  1  1
 1  1  1  1  1

julia&gt; cubes = findhypercubes(A)
CartesianIndices((1:2:3, 1:2:3))

julia&gt; collect(cubes)
2×2 Matrix{CartesianIndex{2}}:
 CartesianIndex(1, 1)  CartesianIndex(1, 3)
 CartesianIndex(3, 1)  CartesianIndex(3, 3)

julia&gt; cubes3 = findhypercubes(ones(Bool, 5, 5, 5))
CartesianIndices((1:2:3, 1:2:3, 1:2:3))

julia&gt; collect(cubes3)
2×2×2 Array{CartesianIndex{3}, 3}:
[:, :, 1] =
 CartesianIndex(1, 1, 1)  CartesianIndex(1, 3, 1)
 CartesianIndex(3, 1, 1)  CartesianIndex(3, 3, 1)

[:, :, 2] =
 CartesianIndex(1, 1, 3)  CartesianIndex(1, 3, 3)
 CartesianIndex(3, 1, 3)  CartesianIndex(3, 3, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbshannon/MultiBisect.jl/blob/f869351e8904f15a235fc8309d512480ac7b6dd6/src/bisection.jl#L219-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiBisect.forwardinds-Tuple{Any}" href="#MultiBisect.forwardinds-Tuple{Any}"><code>MultiBisect.forwardinds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">forwardinds(d)</code></pre><p>Get CartesianIndex steps forward in each of <code>d</code> dimensions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; forwardinds(1)
(CartesianIndex(1,),)

julia&gt; forwardinds(2)
(CartesianIndex(1, 0), CartesianIndex(0, 1))

julia&gt; forwardinds(3)
(CartesianIndex(1, 0, 0), CartesianIndex(0, 1, 0), CartesianIndex(0, 0, 1))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbshannon/MultiBisect.jl/blob/f869351e8904f15a235fc8309d512480ac7b6dd6/src/interpolation.jl#L2-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiBisect.interpolate-Tuple{Any, BisectionGrid}" href="#MultiBisect.interpolate-Tuple{Any, BisectionGrid}"><code>MultiBisect.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interpolate(rootfinder, BG::BisectionGrid{T, N}; threaded=false) where {T, N}</code></pre><p>Compute the roots along all bracketing edges of <code>BG</code>.</p><p>The function <code>rootfinder</code> can be any method that receives an edge and returns a root, such as <a href="#MultiBisect.edgeroot-Tuple{Any, Any, Any}"><code>edgeroot</code></a>, <a href="#MultiBisect.linearroot-Tuple{Any, Any}"><code>linearroot</code></a>, or <a href="#MultiBisect.marchingsquares-Tuple{Any}"><code>marchingsquares</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f(x) = 1 - sum(abs2, x); # unit circle

julia&gt; BG = bisect(f, (0.0:1.0, 0.0:1.0); iterations=3);

julia&gt; interpolate(marchingsquares, BG)
8-element Vector{Tuple{Float64, Float64}}:
 (0.875, 0.0)
 (0.875, 0.25)
 (0.875, 0.5)
 (0.75, 0.625)
 (0.0, 0.875)
 (0.25, 0.875)
 (0.625, 0.75)
 (0.5, 0.875)

julia&gt; interpolate(edge -&gt; linearroot(f, edge), BG)
8-element Vector{Tuple{Float64, Float64}}:
 (1.0, 0.0)
 (0.9642857142857143, 0.25)
 (0.8571428571428571, 0.5)
 (0.75, 0.65)
 (0.0, 1.0)
 (0.25, 0.9642857142857143)
 (0.65, 0.75)
 (0.5, 0.8571428571428571)

julia&gt; interpolate(edge -&gt; edgeroot(f, edge, Roots.ITP()), BG)
8-element Vector{Tuple{Float64, Float64}}:
 (1.0, 0.0)
 (0.9682458365518543, 0.25)
 (0.8660254037844387, 0.5)
 (0.75, 0.6614378277661477)
 (0.0, 1.0)
 (0.25, 0.9682458365518543)
 (0.6614378277661477, 0.75)
 (0.5, 0.8660254037844387)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbshannon/MultiBisect.jl/blob/f869351e8904f15a235fc8309d512480ac7b6dd6/src/interpolation.jl#L280-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiBisect.interpolate-Tuple{BisectionGrid}" href="#MultiBisect.interpolate-Tuple{BisectionGrid}"><code>MultiBisect.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interpolate(BG::BisectionGrid{T, N}) where {T, N}</code></pre><p>Compute the roots along all bracketing edges of <code>BG</code> with a linear approximation using precomputed function evaluations. Equivalent to <code>interpolate(linearroot(f), BG)</code>, but does not require re-evaluating the function at each edge.</p><p><strong>Examples</strong></p><p>```jldoctest julia&gt; f(x) = 1 - sum(abs2, x); # unit circle</p><p>julia&gt; BG = bisect(f, (0.0:1.0, 0.0:1.0); iterations=3);</p><p>julia&gt; interpolate(linearroot(f), BG) 8-element Vector{Tuple{Float64, Float64}}:  (1.0, 0.0)  (0.9642857142857143, 0.25)  (0.8571428571428571, 0.5)  (0.75, 0.65)  (0.0, 1.0)  (0.25, 0.9642857142857143)  (0.65, 0.75)  (0.5, 0.8571428571428571)</p><p>julia&gt; interpolate(BG) 8-element Vector{Tuple{Float64, Float64}}:  (1.0, 0.0)  (0.9642857142857143, 0.25)  (0.8571428571428571, 0.5)  (0.75, 0.65)  (0.0, 1.0)  (0.25, 0.9642857142857143)  (0.65, 0.75)  (0.5, 0.8571428571428571)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbshannon/MultiBisect.jl/blob/f869351e8904f15a235fc8309d512480ac7b6dd6/src/interpolation.jl#L338-L372">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiBisect.linearroot-Tuple{Any, Any}" href="#MultiBisect.linearroot-Tuple{Any, Any}"><code>MultiBisect.linearroot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linearroot(f, edge)</code></pre><p>Construct a linear interpolation of <code>f</code> through <code>edge</code> and return its root. Requires two function evaluations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f(x) = 1 - sum(abs2, x); # unit circle

julia&gt; BG = bisect(f, (0.0:1.0, 0.0:1.0); iterations=3);

julia&gt; E = edges(BG)
8-element Vector{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}:
 ((0.75, 0.0), (1.0, 0.0))
 ((0.75, 0.25), (1.0, 0.25))
 ((0.75, 0.5), (1.0, 0.5))
 ((0.75, 0.5), (0.75, 0.75))
 ((0.0, 0.75), (0.0, 1.0))
 ((0.25, 0.75), (0.25, 1.0))
 ((0.5, 0.75), (0.75, 0.75))
 ((0.5, 0.75), (0.5, 1.0))

julia&gt; linearroot.(f, E)
8-element Vector{Tuple{Float64, Float64}}:
 (1.0, 0.0)
 (0.9642857142857143, 0.25)
 (0.8571428571428571, 0.5)
 (0.75, 0.65)
 (0.0, 1.0)
 (0.25, 0.9642857142857143)
 (0.65, 0.75)
 (0.5, 0.8571428571428571)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbshannon/MultiBisect.jl/blob/f869351e8904f15a235fc8309d512480ac7b6dd6/src/interpolation.jl#L234-L269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiBisect.marchingsquares-Tuple{Any}" href="#MultiBisect.marchingsquares-Tuple{Any}"><code>MultiBisect.marchingsquares</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">marchingsquares(edge)</code></pre><p>Return the midpoint of the edge, in a manner similar to the <a href="https://en.wikipedia.org/wiki/Marching_squares">marching squares algorithm</a>. Does not require any function evaluations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f(x) = 1 - sum(abs2, x); # unit circle

julia&gt; BG = bisect(f, (0.0:1.0, 0.0:1.0); iterations=3);


julia&gt; E = edges(BG)
8-element Vector{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}:
 ((0.75, 0.0), (1.0, 0.0))
 ((0.75, 0.25), (1.0, 0.25))
 ((0.75, 0.5), (1.0, 0.5))
 ((0.75, 0.5), (0.75, 0.75))
 ((0.0, 0.75), (0.0, 1.0))
 ((0.25, 0.75), (0.25, 1.0))
 ((0.5, 0.75), (0.75, 0.75))
 ((0.5, 0.75), (0.5, 1.0))

julia&gt; marchingsquares.(E)
8-element Vector{Tuple{Float64, Float64}}:
 (0.875, 0.0)
 (0.875, 0.25)
 (0.875, 0.5)
 (0.75, 0.625)
 (0.0, 0.875)
 (0.25, 0.875)
 (0.625, 0.75)
 (0.5, 0.875)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbshannon/MultiBisect.jl/blob/f869351e8904f15a235fc8309d512480ac7b6dd6/src/interpolation.jl#L192-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiBisect.splitsign-Tuple{BisectionGrid}" href="#MultiBisect.splitsign-Tuple{BisectionGrid}"><code>MultiBisect.splitsign</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splitsign(BG::BisectionGrid)</code></pre><p>Split the evaluated points of the bisection grid into a vector of positive points and a vector of negative points.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; BG = bisect(x -&gt; 1 - sum(abs2, x), (0.0:1.0, 0.0:1.0); iterations=2)
BisectionGrid{Float64, 2}
       Domain: (0.0:0.5:1.0, 0.0:0.5:1.0)
  Grid points: 9
  Evaluations: 9
        Edges: 4

julia&gt; posx, negx = splitsign(BG);


julia&gt; posx
4-element Vector{Tuple{Float64, Float64}}:
 (0.0, 0.0)
 (0.5, 0.0)
 (0.0, 0.5)
 (0.5, 0.5)

julia&gt; negx
5-element Vector{Tuple{Float64, Float64}}:
 (1.0, 0.0)
 (1.0, 0.5)
 (0.0, 1.0)
 (0.5, 1.0)
 (1.0, 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbshannon/MultiBisect.jl/blob/f869351e8904f15a235fc8309d512480ac7b6dd6/src/bisection.jl#L49-L81">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.1 on <span class="colophon-date" title="Thursday 28 March 2024 19:24">Thursday 28 March 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
