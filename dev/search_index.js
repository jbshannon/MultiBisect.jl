var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [MultiBisect]","category":"page"},{"location":"api/#MultiBisect.bisect-Tuple{Any, Any}","page":"API Reference","title":"MultiBisect.bisect","text":"bisect(f, grid; threaded=false, monotonic=false, iterations=5, verbose=false)\n\nPerform the multidimensional bisection algorithm of function f on an initial grid of evaluation points.\n\nArguments\n\nPositional Arguments\n\nf: function to be evaluated\ngrid: a tuple of ranges describing the initial evaluation grid\n\nKeyword Arguments\n\nthreaded: set to true for multithreaded evaluation\nmonotonic: set to true if f is known to be monotonic in each dimension\niterations: number of times to iterate the algorithm\nverbose: set to true to print the number of new function evaluations at each iteration\n\nExamples\n\njulia> grid = (0.0:1.0, 0.0:1.0);\n\njulia> bisect(x -> 1 - sum(abs2, x), grid)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.0625:1.0, 0.0:0.0625:1.0)\n  Grid points: 289\n  Evaluations: 112\n        Edges: 32\n\n\njulia> bisect(x -> x[2] - x[1], grid)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.0625:1.0, 0.0:0.0625:1.0)\n  Grid points: 289\n  Evaluations: 112\n        Edges: 32\n\n\njulia> bisect(x -> x[2] - x[1], grid; monotonic=true)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.0625:1.0, 0.0:0.0625:1.0)\n  Grid points: 289\n  Evaluations: 67\n        Edges: 32\n\nExtended help\n\nAlgorithm\n\nThe algorithm begins with an initial evaluation grid of N-dimensional hypercubes (lines, squares, cubes, etc.) and proceeds by splitting it in \"half\" at each stage, but only in regions where the function is known to change sign. After the function is evaluated, each hypercube is split in half (a line into two lines, a square into four squares, a cube into eight cubes, etc.) and the function sign at each vertex is checked. If not all vertices share the same sign, the function must change sign somewhere within the hypercube, so the vertices of the subcubes (e.g. the midpoint of a line) will be marked for evaluation in the next stage; if the vertices all share the same sign, the function is presumed to have the same sign everywhere throughout the hypercube, so the sign is inferred at all interior points and the function is not evaluated in the hypercube again.\n\nBy passing the keyword monotonic=true, the algorithm further assumes that the function cannot change sign in any one direction between two points with the same sign. This means that the sign of the function should be checked at the vertices of each edge of the hypercube; if the signs are the same, the function is assumed to have the same sign at the midpoint along the edge and will not be evaluated.\n\nMultithreading\n\nSet the keyword argument threaded=true to make evaluation of the function at each iteration multithreaded. For functions that are very cheap to evaluate, the overhead from setting up threads will actually make each iteration longer. However, this effect disappears quickly.\n\nExample\n\njulia> ffast(x) = 1 - sum(abs2, x);\n\njulia> grid = (0.0:1.0, 0.0:1.0);\n\njulia> @btime bisect(ffast, $grid; threaded=false);\n  49.720 μs (40 allocations: 3.59 KiB)\n\njulia> @btime bisect(ffast, $grid; threaded=true);\n  146.173 μs (163 allocations: 18.23 KiB)\n\njulia> fslow(x) = (sleep(0.1); ffast(x))\nfslow (generic function with 1 method)\n\njulia> @btime bisect(fslow, $grid; threaded=false);\n  11.397 s (605 allocations: 20.83 KiB)\n\njulia> @btime bisect(fslow, $grid; threaded=true);\n  3.170 s (736 allocations: 35.45 KiB)\n\nMonotonicity\n\nIf the function f is known to be monotonic, then the number of evaluations can be reduced by inferring the behavior of f along edges where both vertices have the same sign.\n\nExample\n\njulia> bisect(x -> 1 - sum(abs2, x), (0.0:1.0, 0.0:1.0); monotonic=false)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.0625:1.0, 0.0:0.0625:1.0)\n  Grid points: 289\n  Evaluations: 112\n        Edges: 32\n\n\njulia> bisect(x -> 1 - sum(abs2, x), (0.0:1.0, 0.0:1.0); monotonic=true)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.0625:1.0, 0.0:0.0625:1.0)\n  Grid points: 289\n  Evaluations: 80\n        Edges: 32\n\nIterations\n\nFor finer grids, repeat the algorithm for more iterations.\n\nExample\n\njulia> bisect(x -> 1 - sum(abs2, x), (0.0:1.0, 0.0:1.0))\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.0625:1.0, 0.0:0.0625:1.0)\n  Grid points: 289\n  Evaluations: 112\n        Edges: 32\n\n\njulia> bisect(x -> 1 - sum(abs2, x), (0.0:1.0, 0.0:1.0); iterations=3)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.25:1.0, 0.0:0.25:1.0)\n  Grid points: 25\n  Evaluations: 22\n        Edges: 8\n\n\njulia> bisect(x -> 1 - sum(abs2, x), (0.0:1.0, 0.0:1.0); iterations=7)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.015625:1.0, 0.0:0.015625:1.0)\n  Grid points: 4225\n  Evaluations: 490\n        Edges: 128\n\nLogging\n\nFor longer-running bisections, it may be useful to report the number of new evaluations as a kind of thread-safe progress meter.\n\nExample\n\njulia> bisect(x -> 1 - sum(abs2, x), (0.0:1.0, 0.0:1.0); verbose=true)\n[ Info: Iteration 1: 4 gridpoints (4 evaluations)\n[ Info: Iteration 2: 9 gridpoints (5 evaluations)\n[ Info: Iteration 3: 25 gridpoints (13 evaluations)\n[ Info: Iteration 4: 81 gridpoints (29 evaluations)\n[ Info: Iteration 5: 289 gridpoints (61 evaluations)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.0625:1.0, 0.0:0.0625:1.0)\n  Grid points: 289\n  Evaluations: 112\n        Edges: 32\n\n\njulia> bisect(x -> 1 - sum(abs2, x), (0.0:1.0, 0.0:1.0); verbose=true, iterations=7)\n[ Info: Iteration 1: 4 gridpoints (4 evaluations)\n[ Info: Iteration 2: 9 gridpoints (5 evaluations)\n[ Info: Iteration 3: 25 gridpoints (13 evaluations)\n[ Info: Iteration 4: 81 gridpoints (29 evaluations)\n[ Info: Iteration 5: 289 gridpoints (61 evaluations)\n[ Info: Iteration 6: 1089 gridpoints (125 evaluations)\n[ Info: Iteration 7: 4225 gridpoints (253 evaluations)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.015625:1.0, 0.0:0.015625:1.0)\n  Grid points: 4225\n  Evaluations: 490\n        Edges: 128\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiBisect.corners-Tuple{CartesianIndices}","page":"API Reference","title":"MultiBisect.corners","text":"corners(CI::CartesianIndices)\n\nConstruct an iterator over the corners of the hypercube defined by CI.\n\nExamples\n\njulia> CI = CartesianIndices((1:3, 1:4))\nCartesianIndices((1:3, 1:4))\n\njulia> collect(CI)\n3×4 Matrix{CartesianIndex{2}}:\n CartesianIndex(1, 1)  CartesianIndex(1, 2)  …  CartesianIndex(1, 4)\n CartesianIndex(2, 1)  CartesianIndex(2, 2)     CartesianIndex(2, 4)\n CartesianIndex(3, 1)  CartesianIndex(3, 2)     CartesianIndex(3, 4)\n\njulia> corners(CI)\nCartesianIndices((1:2:3, 1:3:4))\n\njulia> collect(corners(CI))\n2×2 Matrix{CartesianIndex{2}}:\n CartesianIndex(1, 1)  CartesianIndex(1, 4)\n CartesianIndex(3, 1)  CartesianIndex(3, 4)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiBisect.domainindex-Union{Tuple{N}, Tuple{Any, CartesianIndex{N}}} where N","page":"API Reference","title":"MultiBisect.domainindex","text":"domainindex(X, I::CartesianIndex)\n\nLike getindex, except X is a tuple of ranges instead of an array.\n\nExamples\n\njulia> X = (1.0:5.0, 0.5:2.5);\n\njulia> domainindex(X, CartesianIndex(1, 1))\n(1.0, 0.5)\n\njulia> domainindex(X, CartesianIndex(2, 1))\n(2.0, 0.5)\n\njulia> domainindex(X, CartesianIndex(1, 2))\n(1.0, 1.5)\n\njulia> domainindex(X, last(CartesianIndices(eachindex.(X))))\n(5.0, 2.5)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiBisect.edgebounds-Tuple{Any}","page":"API Reference","title":"MultiBisect.edgebounds","text":"edgebounds(edge)\n\nReturn the bounds of the edge in its varying dimension.\n\nExamples\n\njulia> edgebounds(((0.5, 1.0), (1.0, 1.0)))\n(0.5, 1.0)\n\njulia> edgebounds(((0.5, 1.0), (0.5, 1.5)))\n(1.0, 1.5)\n\njulia> edgebounds(((1.0, 1.0, 1.0), (1.0, 1.0, 2.0)))\n(1.0, 2.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiBisect.edgedim-Tuple{Any}","page":"API Reference","title":"MultiBisect.edgedim","text":"edgedim(edge)\n\nReturn the dimension of the edge (i.e. the only direction in which the vertices vary).\n\nExamples\n\njulia> edgedim(((0.5, 1.0), (1.0, 1.0)))\n1\n\njulia> edgedim(((0.5, 1.0), (0.5, 1.5)))\n2\n\njulia> edgedim(((1.0, 1.0, 1.0), (1.0, 1.0, 2.0)))\n3\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiBisect.edgeroot-Tuple{Any, Any, Any}","page":"API Reference","title":"MultiBisect.edgeroot","text":"edgeroot(f, edge, M; kwargs...)\n\nFind the root along edge with a call to Roots.find_zero. Both M and kwargs are passed directly to find_zero.\n\nExamples\n\njulia> f(x) = 1 - sum(abs2, x); # unit circle\n\njulia> BG = bisect(f, (0.0:1.0, 0.0:1.0); iterations=3);\n\n\njulia> E = edges(BG)\n8-element Vector{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}:\n ((0.75, 0.0), (1.0, 0.0))\n ((0.75, 0.25), (1.0, 0.25))\n ((0.75, 0.5), (1.0, 0.5))\n ((0.75, 0.5), (0.75, 0.75))\n ((0.0, 0.75), (0.0, 1.0))\n ((0.25, 0.75), (0.25, 1.0))\n ((0.5, 0.75), (0.75, 0.75))\n ((0.5, 0.75), (0.5, 1.0))\n\njulia> tracks = Roots.Tracks();\n\n\njulia> root = edgeroot(f, E[3], Roots.ITP(); tracks)\n(0.8660254037844387, 0.5)\n\njulia> f(root)\n0.0\n\njulia> tracks\nResults of univariate zero finding:\n\n* Converged to: 0.8660254037844387\n* Algorithm: Roots.ITP{Float64, Int64}(0.2, 2, 1)\n* iterations: 7\n* function evaluations ≈ 9\n* stopped as f(x_n) = 0\n\nTrace:\n(a₀, b₀) = ( 0.75, 1 )\n(a₁, b₁) = ( 0.75, 0.86964285714285705 )\n(a₂, b₂) = ( 0.86290337975046705, 0.86964285714285705 )\n(a₃, b₃) = ( 0.86290337975046705, 0.8660279692952968 )\n(a₄, b₄) = ( 0.86602344653979335, 0.8660279692952968 )\n(a₅, b₅) = ( 0.86602344653979335, 0.86602540378563075 )\n(a₆, b₆) = ( 0.86602540378367243, 0.86602540378563075 )\n(a₇, b₇) = ( 0.86602540378443871, 0.86602540378563075 )\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiBisect.edges-Union{Tuple{BisectionGrid{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"API Reference","title":"MultiBisect.edges","text":"edges(BG::BisectionGrid)\n\nFind all hypercube edges where the sign of the function changes. Returns a Vector of 2-tuples of points in the domain.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiBisect.edgetuple-Tuple{Any}","page":"API Reference","title":"MultiBisect.edgetuple","text":"edgetuple(edge)\n\nReturn a function converting a value along the edge dimension to a point.\n\nExamples\n\njulia> tup = edgetuple(((0.5, 1.0), (1.0, 1.0)));\n\n\njulia> tup(0.75)\n(0.75, 1.0)\n\njulia> tup(0.9)\n(0.9, 1.0)\n\njulia> edgetuple(((0.5, 1.0), (0.5, 1.5)))(1.2)\n(0.5, 1.2)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiBisect.expandzeros-Tuple{Any}","page":"API Reference","title":"MultiBisect.expandzeros","text":"expandzeros(A)\n\nExpand the array A, inserting a zero between each element.\n\nExamples\n\njulia> A = reshape(1:4, 2, 2)\n2×2 reshape(::UnitRange{Int64}, 2, 2) with eltype Int64:\n 1  3\n 2  4\n\njulia> expandzeros(A)\n3×3 Matrix{Int64}:\n 1  0  3\n 0  0  0\n 2  0  4\n\njulia> B = reshape(1:6, 3, 2)\n3×2 reshape(::UnitRange{Int64}, 3, 2) with eltype Int64:\n 1  4\n 2  5\n 3  6\n\njulia> expandzeros(B)\n5×3 Matrix{Int64}:\n 1  0  4\n 0  0  0\n 2  0  5\n 0  0  0\n 3  0  6\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiBisect.findhypercubes-Tuple{Any}","page":"API Reference","title":"MultiBisect.findhypercubes","text":"findhypercubes(A; dist=2)\n\nFind the starting vertex of all hypercubes in the array A.\n\nExamples\n\njulia> A = ones(Bool, 5, 5)\n5×5 Matrix{Bool}:\n 1  1  1  1  1\n 1  1  1  1  1\n 1  1  1  1  1\n 1  1  1  1  1\n 1  1  1  1  1\n\njulia> cubes = findhypercubes(A)\nCartesianIndices((1:2:3, 1:2:3))\n\njulia> collect(cubes)\n2×2 Matrix{CartesianIndex{2}}:\n CartesianIndex(1, 1)  CartesianIndex(1, 3)\n CartesianIndex(3, 1)  CartesianIndex(3, 3)\n\njulia> cubes3 = findhypercubes(ones(Bool, 5, 5, 5))\nCartesianIndices((1:2:3, 1:2:3, 1:2:3))\n\njulia> collect(cubes3)\n2×2×2 Array{CartesianIndex{3}, 3}:\n[:, :, 1] =\n CartesianIndex(1, 1, 1)  CartesianIndex(1, 3, 1)\n CartesianIndex(3, 1, 1)  CartesianIndex(3, 3, 1)\n\n[:, :, 2] =\n CartesianIndex(1, 1, 3)  CartesianIndex(1, 3, 3)\n CartesianIndex(3, 1, 3)  CartesianIndex(3, 3, 3)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiBisect.forwardinds-Tuple{Any}","page":"API Reference","title":"MultiBisect.forwardinds","text":"forwardinds(d)\n\nGet CartesianIndex steps forward in each of d dimensions.\n\nExamples\n\njulia> forwardinds(1)\n(CartesianIndex(1,),)\n\njulia> forwardinds(2)\n(CartesianIndex(1, 0), CartesianIndex(0, 1))\n\njulia> forwardinds(3)\n(CartesianIndex(1, 0, 0), CartesianIndex(0, 1, 0), CartesianIndex(0, 0, 1))\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiBisect.interpolate-Tuple{Any, BisectionGrid}","page":"API Reference","title":"MultiBisect.interpolate","text":"interpolate(rootfinder, BG::BisectionGrid{T, N}; threaded=false) where {T, N}\n\nCompute the roots along all bracketing edges of BG.\n\nThe function rootfinder can be any method that receives an edge and returns a root, such as edgeroot, linearroot, or marchingsquares.\n\nExamples\n\njulia> f(x) = 1 - sum(abs2, x); # unit circle\n\njulia> BG = bisect(f, (0.0:1.0, 0.0:1.0); iterations=3);\n\n\njulia> using MultiBisect: interpolate\n\njulia> interpolate(marchingsquares, BG)\n8-element Vector{Tuple{Float64, Float64}}:\n (0.875, 0.0)\n (0.875, 0.25)\n (0.875, 0.5)\n (0.75, 0.625)\n (0.0, 0.875)\n (0.25, 0.875)\n (0.625, 0.75)\n (0.5, 0.875)\n\njulia> interpolate(edge -> linearroot(f, edge), BG)\n8-element Vector{Tuple{Float64, Float64}}:\n (1.0, 0.0)\n (0.9642857142857143, 0.25)\n (0.8571428571428571, 0.5)\n (0.75, 0.65)\n (0.0, 1.0)\n (0.25, 0.9642857142857143)\n (0.65, 0.75)\n (0.5, 0.8571428571428571)\n\njulia> interpolate(edge -> edgeroot(f, edge, Roots.ITP()), BG)\n8-element Vector{Tuple{Float64, Float64}}:\n (1.0, 0.0)\n (0.9682458365518543, 0.25)\n (0.8660254037844387, 0.5)\n (0.75, 0.6614378277661477)\n (0.0, 1.0)\n (0.25, 0.9682458365518543)\n (0.6614378277661477, 0.75)\n (0.5, 0.8660254037844387)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiBisect.linearroot-Tuple{Any, Any}","page":"API Reference","title":"MultiBisect.linearroot","text":"linearroot(f, edge)\n\nConstruct a linear interpolation of f through edge and return its root. Requires two function evaluations.\n\nExamples\n\njulia> f(x) = 1 - sum(abs2, x); # unit circle\n\njulia> BG = bisect(f, (0.0:1.0, 0.0:1.0); iterations=3);\n\n\njulia> E = edges(BG)\n8-element Vector{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}:\n ((0.75, 0.0), (1.0, 0.0))\n ((0.75, 0.25), (1.0, 0.25))\n ((0.75, 0.5), (1.0, 0.5))\n ((0.75, 0.5), (0.75, 0.75))\n ((0.0, 0.75), (0.0, 1.0))\n ((0.25, 0.75), (0.25, 1.0))\n ((0.5, 0.75), (0.75, 0.75))\n ((0.5, 0.75), (0.5, 1.0))\n\njulia> linearroot.(f, E)\n8-element Vector{Tuple{Float64, Float64}}:\n (1.0, 0.0)\n (0.9642857142857143, 0.25)\n (0.8571428571428571, 0.5)\n (0.75, 0.65)\n (0.0, 1.0)\n (0.25, 0.9642857142857143)\n (0.65, 0.75)\n (0.5, 0.8571428571428571)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiBisect.marchingsquares-Tuple{Any}","page":"API Reference","title":"MultiBisect.marchingsquares","text":"marchingsquares(edge)\n\nReturn the midpoint of the edge, in a manner similar to the marching squares algorithm. Does not require any function evaluations.\n\nExamples\n\njulia> f(x) = 1 - sum(abs2, x); # unit circle\n\njulia> BG = bisect(f, (0.0:1.0, 0.0:1.0); iterations=3);\n\n\njulia> E = edges(BG)\n8-element Vector{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}:\n ((0.75, 0.0), (1.0, 0.0))\n ((0.75, 0.25), (1.0, 0.25))\n ((0.75, 0.5), (1.0, 0.5))\n ((0.75, 0.5), (0.75, 0.75))\n ((0.0, 0.75), (0.0, 1.0))\n ((0.25, 0.75), (0.25, 1.0))\n ((0.5, 0.75), (0.75, 0.75))\n ((0.5, 0.75), (0.5, 1.0))\n\njulia> marchingsquares.(E)\n8-element Vector{Tuple{Float64, Float64}}:\n (0.875, 0.0)\n (0.875, 0.25)\n (0.875, 0.5)\n (0.75, 0.625)\n (0.0, 0.875)\n (0.25, 0.875)\n (0.625, 0.75)\n (0.5, 0.875)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiBisect.revert-Tuple{BisectionGrid}","page":"API Reference","title":"MultiBisect.revert","text":"revert(BG::BisectionGrid; steps=1)\n\nRevert the grid BG by a given number of steps (e.g. go from the fourth iteration back to the third iteration).\n\nExamples\n\njulia> f(x) = 1 - sum(abs2, x);\n\njulia> grid = (0.0:1.0, 0.0:1.0);\n\njulia> BG3 = bisect(f, grid; iterations=3)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.25:1.0, 0.0:0.25:1.0)\n  Grid points: 25\n  Evaluations: 22\n        Edges: 8\n\n\njulia> BG4 = bisect(f, grid; iterations=4)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.125:1.0, 0.0:0.125:1.0)\n  Grid points: 81\n  Evaluations: 51\n        Edges: 16\n\n\njulia> revert(BG4)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.25:1.0, 0.0:0.25:1.0)\n  Grid points: 25\n  Evaluations: 22\n        Edges: 8\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiBisect.splitsign-Tuple{BisectionGrid}","page":"API Reference","title":"MultiBisect.splitsign","text":"splitsign(BG::BisectionGrid)\n\nSplit the evaluated points of the bisection grid into a vector of positive points and a vector of negative points.\n\nExamples\n\njulia> BG = bisect(x -> 1 - sum(abs2, x), (0.0:1.0, 0.0:1.0); iterations=2)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.5:1.0, 0.0:0.5:1.0)\n  Grid points: 9\n  Evaluations: 9\n        Edges: 4\n\njulia> posx, negx = splitsign(BG);\n\n\njulia> posx\n4-element Vector{Tuple{Float64, Float64}}:\n (0.0, 0.0)\n (0.5, 0.0)\n (0.0, 0.5)\n (0.5, 0.5)\n\njulia> negx\n5-element Vector{Tuple{Float64, Float64}}:\n (1.0, 0.0)\n (1.0, 0.5)\n (0.0, 1.0)\n (0.5, 1.0)\n (1.0, 1.0)\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MultiBisect","category":"page"},{"location":"#MultiBisect.jl","page":"Home","title":"MultiBisect.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This Julia package provides a lightweight, idiomatic implementation of the bisection method of root-finding in an arbitrary number of dimensions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package exports the BisectionGrid type, which tracks an N-dimensional bisection with only three Array{Bool, N}s and one NTuple{N, R <: AbstractRange}. Using ordinary boolean arrays not only uses minimal memory, but also leverages the magic of base Julia's CartesianIndices to handle any number of dimensions without code modification.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[!IMPORTANT] This package, while functional, is still experimental and subject to change. For a more mature package with similar functionality, see MDBM.jl","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is not yet registered, so installation is only available by url from the pkg> prompt:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/jbshannon/MultiBisect.jl","category":"page"},{"location":"#The-Problem","page":"Home","title":"The Problem","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The task of finding the root of a continuous function on an interval where its sign is known to change is a relatively well-known and simple problem, but extending the method to handle two or more dimensions adds complexity. For example, consider the unit circle on the domain 01^2.","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(z) = 1 - sum(abs2, z)\ncircle = map(t -> (cos(t), sin(t)), 0:0.01:π/2)\n\nusing CairoMakie\nfig = Figure(resolution = (500, 500))\nax = Axis(fig[1, 1])\nlines!(ax, circle; color=:black)\nfig","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"The naive, brute-force approach would be to evaluate the function on a grid of points, but many of these evaluations would be far away from the root (in two dimensions, a zero level curve) and not provide any information about the shape of the level curve.","category":"page"},{"location":"","page":"Home","title":"Home","text":"xs = range(0, 1, length=65)\nXS = Iterators.product(xs, xs) |> collect\nF = f.(XS)\n\nscatter!(ax, XS[F .> 0]; markersize=3)\nscatter!(ax, XS[F .≤ 0]; markersize=3)\nfig","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"The level curve must lie between the positive points and the negative points. Two adjacent points that share the same sign do not tell us anything about the level curve, so we could improve our efficiency if we avoided evaluating the function in regions where the sign does not appear to change.","category":"page"},{"location":"#Bisection","page":"Home","title":"Bisection","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Using the bisection method, we can reduce the number of function evaluations by increasing the fineness of the grid only in places we know the function must change sign. This package provides the function bisect(f, grid), which applies the algorithm iteratively to the grid using the function f:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MultiBisect\nBG = bisect(f, (0.0:1.0, 0.0:1.0); iterations=7)\nposx, negx = splitsign(BG)\n\nfig = Figure(resolution = (500, 500))\nax = Axis(fig[1, 1])\nlines!(ax, circle; color=:black)\nscatter!(ax, posx; markersize=3)\nscatter!(ax, negx; markersize=3)\nfig","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"The resulting grid is the same size and identifies the exact same sign changes as before, but with far fewer function evaluations – nearly 90% fewer!","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> BG\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.015625:1.0, 0.0:0.015625:1.0)\n  Grid points: 4225\n  Evaluations: 490\n\n\njulia> (xs, xs) == domain(BG)\ntrue\n\njulia> efficiency(BG) # percentage of gridpoints not evaluated\n0.8840236686390532","category":"page"},{"location":"","page":"Home","title":"Home","text":"This efficiency gain is possible because we known that if a square in the grid has vertices that are not all the same sign, the function must change sign somewhere within the square (this is of course only a necessary and not a sufficient condition). The method proceeds by dividing an initial grid \"in half\" (in the multidimensional sense) at each stage. Since we are working in two dimensions, we break each square into four smaller squares. Before evaluating the function, we check the sign of the function at teh vertices of the larger square. If the function does not change sign, there is no need to evaluate the function within the square. By discarding squares whose vertices all share the same sign at each iteration, we avoid uninformative function evaluations. Here is a step-by-step view of the algorithm:","category":"page"},{"location":"","page":"Home","title":"Home","text":"https://github.com/jbshannon/MultiBisect.jl/assets/46204520/f4fa8893-f073-40f7-8907-84308b91cc65","category":"page"},{"location":"#Interpolation","page":"Home","title":"Interpolation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Once we're satisfied we have enough information about where the function changes signs, we need to convert that information into actual points along the curve. This package examines the edges of the grid: two adjacent points with opposite signs. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> edges(BG)\n128-element Vector{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}:\n ((0.984375, 0.0), (1.0, 0.0))\n ((0.984375, 0.015625), (1.0, 0.015625))\n ((0.984375, 0.03125), (1.0, 0.03125))\n ((0.984375, 0.046875), (1.0, 0.046875))\n ((0.984375, 0.0625), (1.0, 0.0625))\n ⋮\n ((0.125, 0.984375), (0.125, 1.0))\n ((0.140625, 0.984375), (0.140625, 1.0))\n ((0.15625, 0.984375), (0.15625, 1.0))\n ((0.171875, 0.984375), (0.1875, 0.984375))\n ((0.171875, 0.984375), (0.171875, 1.0))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since an edge is one-dimensional, we can convert the multidimensional root-finding problem to a series of one-dimensional problems. This packages provides the function interpolate(rootfinder, BG), which takes a function rootfinder – taking an edge as input and returning a root as output – and applies it to each edge in the grid BG. This package currently provides three root-finders for convenience:","category":"page"},{"location":"","page":"Home","title":"Home","text":"edgeroot: solve for the root on the edge with a call to Roots.find_zero\nlinearroot: create a linear interpolation of the function through the two edge points and compute its root\nmarchingsquares: return the midpoint of the edge","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here is a visual comparison of these different interpolation methods:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#More-dimensions!","page":"Home","title":"More dimensions!","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Since Julia has the magical CartesianIndices iterator, translating this process out of two dimensions is as simple as changing the dimension of the initial evaluation grid. Here is an example finding roots of the 5d unit hypersphere over the 5d unit hypercube:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> grid = ntuple(i -> (0.0:1.0), 5)\n(0.0:1.0:1.0, 0.0:1.0:1.0, 0.0:1.0:1.0, 0.0:1.0:1.0, 0.0:1.0:1.0)\n\njulia> BG5 = bisect(f, grid)\nBisectionGrid{Float64, 5}\n       Domain: (0.0:0.0625:1.0, 0.0:0.0625:1.0, 0.0:0.0625:1.0, 0.0:0.0625:1.0, 0.0:0.0625:1.0)\n  Grid points: 1419857\n  Evaluations: 396246\n\njulia> interpolate(linearroot(f), BG5)\n124020-element Vector{NTuple{5, Float64}}:\n (1.0, 0.0, 0.0, 0.0, 0.0)\n (0.9979838709677419, 0.0625, 0.0, 0.0, 0.0)\n (0.9919354838709677, 0.125, 0.0, 0.0, 0.0)\n (0.9818548387096774, 0.1875, 0.0, 0.0, 0.0)\n (0.967741935483871, 0.25, 0.0, 0.0, 0.0)\n ⋮\n (0.0625, 0.0625, 0.125, 0.3125, 0.9375)\n (0.0, 0.08333333333333333, 0.125, 0.3125, 0.9375)\n (0.0, 0.0625, 0.1375, 0.3125, 0.9375)\n (0.0, 0.0625, 0.125, 0.3181818181818182, 0.9375)\n (0.0, 0.0625, 0.125, 0.3125, 0.9395161290322581)","category":"page"}]
}
