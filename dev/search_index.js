var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = MultiBisect","category":"page"},{"location":"#MultiBisect.jl","page":"Home","title":"MultiBisect.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MultiBisect.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [MultiBisect]","category":"page"},{"location":"#MultiBisect.bisect-Tuple{Any, Any}","page":"Home","title":"MultiBisect.bisect","text":"bisect(f, grid; threaded=false, monotonic=false, iterations=5, verbose=false)\n\nPerform the multidimensional bisection algorithm of function f on an initial grid of evaluation points.\n\nArguments\n\nPositional Arguments\n\nf: function to be evaluated\ngrid: a tuple of ranges describing the initial evaluation grid\n\nKeyword Arguments\n\nthreaded: set to true for multithreaded evaluation\nmonotonic: set to true if f is known to be monotonic in each dimension\niterations: number of times to iterate the algorithm\nverbose: set to true to print the number of new function evaluations at each iteration\n\nExamples\n\njulia> grid = (0.0:1.0, 0.0:1.0);\n\njulia> bisect(x -> 1 - sum(abs2, x), grid)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.0625:1.0, 0.0:0.0625:1.0)\n  Grid points: 289\n  Evaluations: 112\n\n\njulia> bisect(x -> x[2] - x[1], grid)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.0625:1.0, 0.0:0.0625:1.0)\n  Grid points: 289\n  Evaluations: 112\n\n\njulia> bisect(x -> x[2] - x[1], grid; monotonic=true)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.0625:1.0, 0.0:0.0625:1.0)\n  Grid points: 289\n  Evaluations: 67\n\nExtended help\n\nAlgorithm\n\nThe algorithm proceeds by splitting a grid of N-dimensional hypercubes in \"half\".\n\nMultithreading\n\nSet the keyword argument threaded=true to make evaluation of the function at each iteration multithreaded. For functions that are very cheap to evaluate, the overhead from setting up threads will actually make each iteration longer. However, this effect disappears quickly.\n\nExample\n\njulia> ffast(x) = 1 - sum(abs2, x);\n\njulia> grid = (0.0:1.0, 0.0:1.0);\n\njulia> @btime bisect(ffast, $grid; threaded=false);\n  49.720 μs (40 allocations: 3.59 KiB)\n\njulia> @btime bisect(ffast, $grid; threaded=true);\n  146.173 μs (163 allocations: 18.23 KiB)\n\njulia> fslow(x) = (sleep(0.1); ffast(x))\nfslow (generic function with 1 method)\n\njulia> @btime bisect(fslow, $grid; threaded=false);\n  11.397 s (605 allocations: 20.83 KiB)\n\njulia> @btime bisect(fslow, $grid; threaded=true);\n  3.170 s (736 allocations: 35.45 KiB)\n\nMonotonicity\n\nIf the function f is known to be monotonic, then the number of evaluations can be reduced by inferring the behavior of f along edges where both vertices have the same sign.\n\nExample\n\njulia> bisect(x -> 1 - sum(abs2, x), (0.0:1.0, 0.0:1.0); monotonic=false)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.0625:1.0, 0.0:0.0625:1.0)\n  Grid points: 289\n  Evaluations: 112\n\n\njulia> bisect(x -> 1 - sum(abs2, x), (0.0:1.0, 0.0:1.0); monotonic=true)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.0625:1.0, 0.0:0.0625:1.0)\n  Grid points: 289\n  Evaluations: 80\n\nIterations\n\nFor finer grids, repeat the algorithm for more iterations.\n\nExample\n\njulia> bisect(x -> 1 - sum(abs2, x), (0.0:1.0, 0.0:1.0))\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.0625:1.0, 0.0:0.0625:1.0)\n  Grid points: 289\n  Evaluations: 112\n\n\njulia> bisect(x -> 1 - sum(abs2, x), (0.0:1.0, 0.0:1.0); iterations=3)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.25:1.0, 0.0:0.25:1.0)\n  Grid points: 25\n  Evaluations: 22\n\n\njulia> bisect(x -> 1 - sum(abs2, x), (0.0:1.0, 0.0:1.0); iterations=7)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.015625:1.0, 0.0:0.015625:1.0)\n  Grid points: 4225\n  Evaluations: 490\n\nLogging\n\nFor longer-running bisections, it may be useful to report the number of new evaluations as a kind of thread-safe progress meter.\n\nExample\n\njulia> bisect(x -> 1 - sum(abs2, x), (0.0:1.0, 0.0:1.0); verbose=true)\n[ Info: Iteration 1: 4 gridpoints (4 evaluations)\n[ Info: Iteration 2: 9 gridpoints (5 evaluations)\n[ Info: Iteration 3: 25 gridpoints (13 evaluations)\n[ Info: Iteration 4: 81 gridpoints (29 evaluations)\n[ Info: Iteration 5: 289 gridpoints (61 evaluations)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.0625:1.0, 0.0:0.0625:1.0)\n  Grid points: 289\n  Evaluations: 112\n\n\njulia> bisect(x -> 1 - sum(abs2, x), (0.0:1.0, 0.0:1.0); verbose=true, iterations=7)\n[ Info: Iteration 1: 4 gridpoints (4 evaluations)\n[ Info: Iteration 2: 9 gridpoints (5 evaluations)\n[ Info: Iteration 3: 25 gridpoints (13 evaluations)\n[ Info: Iteration 4: 81 gridpoints (29 evaluations)\n[ Info: Iteration 5: 289 gridpoints (61 evaluations)\n[ Info: Iteration 6: 1089 gridpoints (125 evaluations)\n[ Info: Iteration 7: 4225 gridpoints (253 evaluations)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.015625:1.0, 0.0:0.015625:1.0)\n  Grid points: 4225\n  Evaluations: 490\n\n\n\n\n\n","category":"method"},{"location":"#MultiBisect.corners-Tuple{CartesianIndices}","page":"Home","title":"MultiBisect.corners","text":"corners(CI::CartesianIndices)\n\nConstruct an iterator over the corners of the hypercube defined by CI.\n\nExamples\n\njulia> CI = CartesianIndices((1:3, 1:4))\nCartesianIndices((1:3, 1:4))\n\njulia> collect(CI)\n3×4 Matrix{CartesianIndex{2}}:\n CartesianIndex(1, 1)  CartesianIndex(1, 2)  CartesianIndex(1, 3)  CartesianIndex(1, 4)\n CartesianIndex(2, 1)  CartesianIndex(2, 2)  CartesianIndex(2, 3)  CartesianIndex(2, 4)\n CartesianIndex(3, 1)  CartesianIndex(3, 2)  CartesianIndex(3, 3)  CartesianIndex(3, 4)\n\njulia> corners(CI)\nCartesianIndices((1:2:3, 1:3:4))\n\njulia> collect(corners(CI))\n2×2 Matrix{CartesianIndex{2}}:\n CartesianIndex(1, 1)  CartesianIndex(1, 4)\n CartesianIndex(3, 1)  CartesianIndex(3, 4)\n\n\n\n\n\n","category":"method"},{"location":"#MultiBisect.domainindex-Union{Tuple{N}, Tuple{Any, CartesianIndex{N}}} where N","page":"Home","title":"MultiBisect.domainindex","text":"domainindex(X, I::CartesianIndex)\n\nLike getindex, except X is a tuple of ranges instead of an array.\n\nExamples\n\njulia> X = (1.0:5.0, 0.5:2.5);\n\njulia> domainindex(X, CartesianIndex(1, 1))\n(1.0, 0.5)\n\njulia> domainindex(X, CartesianIndex(2, 1))\n(2.0, 0.5)\n\njulia> domainindex(X, CartesianIndex(1, 2))\n(1.0, 1.5)\n\njulia> domainindex(X, last(CartesianIndices(eachindex.(X))))\n(5.0, 2.5)\n\n\n\n\n\n","category":"method"},{"location":"#MultiBisect.edgebounds-Tuple{Any}","page":"Home","title":"MultiBisect.edgebounds","text":"edgebounds(edge)\n\nReturn the bounds of the edge in its varying dimension.\n\nExamples\n\njulia> edgebounds(((0.5, 1.0), (1.0, 1.0)))\n(0.5, 1.0)\n\njulia> edgebounds(((0.5, 1.0), (0.5, 1.5)))\n(1.0, 1.5)\n\njulia> edgebounds(((1.0, 1.0, 1.0), (1.0, 1.0, 2.0)))\n(1.0, 2.0)\n\n\n\n\n\n","category":"method"},{"location":"#MultiBisect.edgedim-Tuple{Any}","page":"Home","title":"MultiBisect.edgedim","text":"edgedim(edge)\n\nReturn the dimension of the edge (i.e. the only direction in which the vertices vary).\n\nExamples\n\njulia> edgedim(((0.5, 1.0), (1.0, 1.0)))\n1\n\njulia> edgedim(((0.5, 1.0), (0.5, 1.5)))\n2\n\njulia> edgedim(((1.0, 1.0, 1.0), (1.0, 1.0, 2.0)))\n3\n\n\n\n\n\n","category":"method"},{"location":"#MultiBisect.edgeroot-Tuple{Any, Any, Any}","page":"Home","title":"MultiBisect.edgeroot","text":"edgeroot(f, edge, M; kwargs...)\n\nFind the root along edge with a call to Roots.find_zero. Both M and kwargs are passed directly to find_zero.\n\nExamples\n\njulia> f(x) = 1 - sum(abs2, x); # unit circle\n\njulia> BG = bisect(f, (0.0:1.0, 0.0:1.0); iterations=3);\n\njulia> E = edges(BG)\n8-element Vector{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}:\n ((0.75, 0.0), (1.0, 0.0))\n ((0.75, 0.25), (1.0, 0.25))\n ((0.75, 0.5), (1.0, 0.5))\n ((0.75, 0.5), (0.75, 0.75))\n ((0.0, 0.75), (0.0, 1.0))\n ((0.25, 0.75), (0.25, 1.0))\n ((0.5, 0.75), (0.75, 0.75))\n ((0.5, 0.75), (0.5, 1.0))\n\njulia> tracks = Roots.Tracks();\n\njulia> root = edgeroot(f, E[3], Roots.ITP(); tracks)\n(0.8660254037844387, 0.5)\n\njulia> f(root)\n0.0\n\njulia> tracks\nResults of univariate zero finding:\n\n* Converged to: 0.8660254037844387\n* Algorithm: Roots.ITP{Float64, Int64}(0.2, 2, 1)\n* iterations: 7\n* function evaluations ≈ 9\n* stopped as f(x_n) = 0\n\nTrace:\n(a₀, b₀) = ( 0.75, 1 )\n(a₁, b₁) = ( 0.75, 0.86964285714285705 )\n(a₂, b₂) = ( 0.86290337975046705, 0.86964285714285705 )\n(a₃, b₃) = ( 0.86290337975046705, 0.8660279692952968 )\n(a₄, b₄) = ( 0.86602344653979335, 0.8660279692952968 )\n(a₅, b₅) = ( 0.86602344653979335, 0.86602540378563075 )\n(a₆, b₆) = ( 0.86602540378367243, 0.86602540378563075 )\n(a₇, b₇) = ( 0.86602540378443871, 0.86602540378563075 )\n\n\n\n\n\n","category":"method"},{"location":"#MultiBisect.edges-Union{Tuple{BisectionGrid{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Home","title":"MultiBisect.edges","text":"edges(BG::BisectionGrid{T, N}) where {T, N}\n\nFind all hypercube edges where the sign of the function changes. Returns a Vector of 2-tuples of points in the domain.\n\n\n\n\n\n","category":"method"},{"location":"#MultiBisect.edgetuple-Tuple{Any}","page":"Home","title":"MultiBisect.edgetuple","text":"edgetuple(edge)\n\nReturn a function converting a value along the edge dimension to a point.\n\nExamples\n\njulia> tup = edgetuple(((0.5, 1.0), (1.0, 1.0)));\n\njulia> tup(0.75)\n(0.75, 1.0)\n\njulia> tup(0.9)\n(0.9, 1.0)\n\njulia> edgetuple(((0.5, 1.0), (0.5, 1.5)))(1.2)\n(0.5, 1.2)\n\n\n\n\n\n","category":"method"},{"location":"#MultiBisect.expandzeros-Tuple{Any}","page":"Home","title":"MultiBisect.expandzeros","text":"expandzeros(A)\n\nExpand the array A, inserting a zero between each element.\n\nExamples\n\njulia> A = reshape(1:4, 2, 2)\n2×2 reshape(::UnitRange{Int64}, 2, 2) with eltype Int64:\n 1  3\n 2  4\n\njulia> expandzeros(A)\n3×3 Matrix{Int64}:\n 1  0  3\n 0  0  0\n 2  0  4\n\njulia> B = reshape(1:6, 3, 2)\n3×2 reshape(::UnitRange{Int64}, 3, 2) with eltype Int64:\n 1  4\n 2  5\n 3  6\n\njulia> expandzeros(B)\n5×3 Matrix{Int64}:\n 1  0  4\n 0  0  0\n 2  0  5\n 0  0  0\n 3  0  6\n\n\n\n\n\n","category":"method"},{"location":"#MultiBisect.forwardinds-Tuple{Any}","page":"Home","title":"MultiBisect.forwardinds","text":"forwardinds(d)\n\nGet CartesianIndex steps forward in each of d dimensions.\n\nExamples\n\njulia> forwardinds(1)\n(CartesianIndex(1,),)\n\njulia> forwardinds(2)\n(CartesianIndex(1, 0), CartesianIndex(0, 1))\n\njulia> forwardinds(3)\n(CartesianIndex(1, 0, 0), CartesianIndex(0, 1, 0), CartesianIndex(0, 0, 1))\n\n\n\n\n\n","category":"method"},{"location":"#MultiBisect.interpolate-Union{Tuple{N}, Tuple{T}, Tuple{Any, BisectionGrid{T, N}}} where {T, N}","page":"Home","title":"MultiBisect.interpolate","text":"interpolate(rootfinder, BG::BisectionGrid{T, N}; threaded=false) where {T, N}\n\nCompute the roots along all bracketing edges of BG.\n\nThe function rootfinder can be any method that receives an edge and returns a root, such as edgeroot, linearroot, or marchingsquares.\n\nExamples\n\njulia> f(x) = 1 - sum(abs2, x); # unit circle\n\njulia> BG = bisect(f, (0.0:1.0, 0.0:1.0); iterations=3);\n\njulia> using MultiBisect: interpolate\n\njulia> interpolate(marchingsquares, BG)\n8-element Vector{Tuple{Float64, Float64}}:\n (0.875, 0.0)\n (0.875, 0.25)\n (0.875, 0.5)\n (0.75, 0.625)\n (0.0, 0.875)\n (0.25, 0.875)\n (0.625, 0.75)\n (0.5, 0.875)\n\njulia> interpolate(edge -> linearroot(f, edge), BG)\n8-element Vector{Tuple{Float64, Float64}}:\n (1.0, 0.0)\n (0.9642857142857143, 0.25)\n (0.8571428571428571, 0.5)\n (0.75, 0.65)\n (0.0, 1.0)\n (0.25, 0.9642857142857143)\n (0.65, 0.75)\n (0.5, 0.8571428571428571)\n\njulia> interpolate(edge -> edgeroot(f, edge, Roots.ITP()), BG)\n8-element Vector{Tuple{Float64, Float64}}:\n (1.0, 0.0)\n (0.9682458365518543, 0.25)\n (0.8660254037844387, 0.5)\n (0.75, 0.6614378277661477)\n (0.0, 1.0)\n (0.25, 0.9682458365518543)\n (0.6614378277661477, 0.75)\n (0.5, 0.8660254037844387)\n\n\n\n\n\n","category":"method"},{"location":"#MultiBisect.linearroot-Tuple{Any, Any}","page":"Home","title":"MultiBisect.linearroot","text":"linearroot(f, edge)\n\nConstruct a linear interpolation of f through edge and return its root. Requires two function evaluations.\n\nExamples\n\njulia> f(x) = 1 - sum(abs2, x); # unit circle\n\njulia> BG = bisect(f, (0.0:1.0, 0.0:1.0); iterations=3);\n\njulia> E = edges(BG)\n8-element Vector{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}:\n ((0.75, 0.0), (1.0, 0.0))\n ((0.75, 0.25), (1.0, 0.25))\n ((0.75, 0.5), (1.0, 0.5))\n ((0.75, 0.5), (0.75, 0.75))\n ((0.0, 0.75), (0.0, 1.0))\n ((0.25, 0.75), (0.25, 1.0))\n ((0.5, 0.75), (0.75, 0.75))\n ((0.5, 0.75), (0.5, 1.0))\n\njulia> linearroot.(f, E)\n8-element Vector{Tuple{Float64, Float64}}:\n (1.0, 0.0)\n (0.9642857142857143, 0.25)\n (0.8571428571428571, 0.5)\n (0.75, 0.65)\n (0.0, 1.0)\n (0.25, 0.9642857142857143)\n (0.65, 0.75)\n (0.5, 0.8571428571428571)\n\n\n\n\n\n","category":"method"},{"location":"#MultiBisect.marchingsquares-Tuple{Any}","page":"Home","title":"MultiBisect.marchingsquares","text":"marchingsquares(edge)\n\nReturn the midpoint of the edge, in a manner similar to the marching squares algorithm. Does not require any function evaluations.\n\nExamples\n\njulia> f(x) = 1 - sum(abs2, x); # unit circle\n\njulia> BG = bisect(f, (0.0:1.0, 0.0:1.0); iterations=3);\n\njulia> E = edges(BG)\n8-element Vector{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}:\n ((0.75, 0.0), (1.0, 0.0))\n ((0.75, 0.25), (1.0, 0.25))\n ((0.75, 0.5), (1.0, 0.5))\n ((0.75, 0.5), (0.75, 0.75))\n ((0.0, 0.75), (0.0, 1.0))\n ((0.25, 0.75), (0.25, 1.0))\n ((0.5, 0.75), (0.75, 0.75))\n ((0.5, 0.75), (0.5, 1.0))\n\njulia> marchingsquares.(E)\n8-element Vector{Tuple{Float64, Float64}}:\n (0.875, 0.0)\n (0.875, 0.25)\n (0.875, 0.5)\n (0.75, 0.625)\n (0.0, 0.875)\n (0.25, 0.875)\n (0.625, 0.75)\n (0.5, 0.875)\n\n\n\n\n\n","category":"method"},{"location":"#MultiBisect.revert-Tuple{BisectionGrid}","page":"Home","title":"MultiBisect.revert","text":"revert(BG::BisectionGrid; steps=1)\n\nRevert the grid BG by a given number of steps (e.g. go from the fourth iteration back to the third iteration).\n\nExamples\n\njulia> f(x) = 1 - sum(abs2, x);\n\njulia> grid = (0.0:1.0, 0.0:1.0);\n\njulia> BG3 = bisect(f, grid; iterations=3)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.25:1.0, 0.0:0.25:1.0)\n  Grid points: 25\n  Evaluations: 22\n\n\njulia> BG4 = bisect(f, grid; iterations=4)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.125:1.0, 0.0:0.125:1.0)\n  Grid points: 81\n  Evaluations: 51\n\n\njulia> revert(BG4)\nBisectionGrid{Float64, 2}\n       Domain: (0.0:0.25:1.0, 0.0:0.25:1.0)\n  Grid points: 25\n  Evaluations: 22\n\n\n\n\n\n","category":"method"}]
}
